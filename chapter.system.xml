<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="system" ?>
	<title>Systems architecture(系统架构)</title>
	<subtitle>Systems architecture</subtitle>
	<screen>
	<![CDATA[
                                       .---> media [mp3, wma, wmv, rmvb, asf, divx]-\
                                      /                                       +------------+
                                     .-----> photo [gif, jpg, png, swf] ----> | Raid Array | <--.
    /------------------- <---------\/                                         +------------+     \
user -> dns -> load balancing -> squid -> [cache] <----[html]----\                  /            |
                 \ \ \______<______/\                      +-------------+         /             |
                  \ \                \-----> web app ----> | html        |--------^              |
                   \ \____________________________/\       | php,jsp,cgi |                       |
                    \                               \      +-------------+                       |
                     \                               `-----> memcached [node1, node2, node(n)]   |
                      \__________________________________________/\                              |
                                                                   `------> Database cluster     |
    +--------------------------------------+                                      \              |
    | Author: neo chen <openunix#163.com>  |                                       `-------------+
    | Nickname: netkiller                  |
    | Homepage: http://netkiller.github.io |
    +--------------------------------------+
	]]>
	</screen>	
	<section id="cluster">
		<title>集群(Cluster)</title>
		<!-- standalone system -->
		<orderedlist>
			<title>集群有很多实现方法，分为硬件和软件，集群可以在不同网络层面上实现</title>
			<listitem><para>实现IP轮循（Bind DNS）</para></listitem>
			<listitem><para>硬件四层交换（硬件负载均衡设备 F5 BIG IP）</para></listitem>
			<listitem><para>软件四层交换（linux virtual server）</para></listitem>
			<listitem><para>应用层上实现（tomcat）</para></listitem>
		</orderedlist>
		<para>越是低层性能越好，越是上层功能更强</para>
		<orderedlist>
			<title>集群的分类</title>
			<listitem><para>高可用性集群</para></listitem>
			<listitem><para>负载均衡集群</para></listitem>
			<listitem><para>超级计算集群</para></listitem>
		</orderedlist>
		<para>网站一般用到两种集群分别是高可用性集群和负载均衡集群</para>
		<section>
			<title>负载均衡</title>
		<section>
			<title>DNS负载均衡</title>
			<para>这是早期出现的负载均衡技术，直到现在，很多网站仍然使用DNS负载均衡。</para>
			<para>你可通过ping命令观看它是如何工作的，例如你可反复ping个网域名。</para>
			<screen>
			<![CDATA[
C:\>ping www.163.com

Pinging www.cache.split.netease.com [220.181.28.52] with 32 bytes of data:

Reply from 220.181.28.52: bytes=32 time=226ms TTL=53
Reply from 220.181.28.52: bytes=32 time=225ms TTL=53
Reply from 220.181.28.52: bytes=32 time=226ms TTL=53
Reply from 220.181.28.52: bytes=32 time=226ms TTL=53

Ping statistics for 220.181.28.52:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 225ms, Maximum = 226ms, Average = 225ms

C:\>ping www.163.com

Pinging www.cache.split.netease.com [220.181.28.53] with 32 bytes of data:

Reply from 220.181.28.53: bytes=32 time=52ms TTL=52
Reply from 220.181.28.53: bytes=32 time=53ms TTL=52
Reply from 220.181.28.53: bytes=32 time=52ms TTL=52
Reply from 220.181.28.53: bytes=32 time=52ms TTL=52

Ping statistics for 220.181.28.53:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 52ms, Maximum = 53ms, Average = 52ms

C:\>ping www.163.com

Pinging www.cache.split.netease.com [220.181.28.50] with 32 bytes of data:

Reply from 220.181.28.50: bytes=32 time=51ms TTL=53
Reply from 220.181.28.50: bytes=32 time=52ms TTL=53
Reply from 220.181.28.50: bytes=32 time=52ms TTL=53
Reply from 220.181.28.50: bytes=32 time=51ms TTL=53

Ping statistics for 220.181.28.50:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 51ms, Maximum = 52ms, Average = 51ms

C:\>
			]]>
			</screen>
			<orderedlist>
				<title>DNS负载均衡主要优点</title>
				<listitem><para>技术简单，容易实现，灵活，方便，成本低</para></listitem>
				<listitem><para>Web服务器可以位于互联网的任意位置上，无地理限制。</para></listitem>
				<listitem><para>DNS的主从结构非常稳定</para></listitem>
				<listitem><para>可以有效的分散DDOS攻击。</para></listitem>
				<listitem><para>你甚至可以在DNS服务商那里实现，自己不需要添加设备。而且没有带宽开销。</para></listitem>
			</orderedlist>
			<orderedlist>
				<title>DNS负载均衡主要缺点</title>
				<listitem><para>DNS负载均衡采用的是简单的轮循负载算法，不能够按照服务器节点的处理能力分配负载。</para></listitem>
				<listitem><para>不支持故障转移(failover)和自动恢复failback ,如果某台服务器拓机，DNS仍会将用户解析到这台故障服务器上，导致不能响应客户端。</para></listitem>
				<listitem><para>如果添加节点或撤出节点，不能即时更新到省市级DNS,可导致部分地区不能访问。</para></listitem>
				<listitem><para>占用大量静态IP。</para></listitem>
			</orderedlist>
		</section>
		<section>
			<title>软件四层交换负载均衡</title>
			<orderedlist>
				<title>软件四层交换负载均衡为我们解决了几个问题</title>
				<listitem><para>能够按照服务器节点的处理能力分配负载。</para></listitem>
				<listitem><para>支持故障转移(failover)和自动恢复failback ,如果某节点拓机，调度器自动将它剔除，不响应客户端访问，当节点故障排除调度器立即恢复节点。</para></listitem>
				<listitem><para>可以随时添加节点或撤出节点，即时生效,方便网站扩容。</para></listitem>
			</orderedlist>
			<orderedlist>
				<title>软件四层交换负载均衡优点</title>
				<listitem><para>仅仅需要一个静态IP。</para></listitem>
				<listitem><para>节点位于私有网络上与WAN隔离，用户面对的只是调度器。</para></listitem>
				<listitem><para>可以随时添加节点或撤出节点。</para></listitem>
				<listitem><para>通过端口可以组建多个集群。</para></listitem>
			</orderedlist>

		</section>
		<section>
			<title>应用层负载均衡</title>

			<para>Tomcat balancer</para>
			<para>mod_proxy_balancer.so ,tomcat mod_jk.so</para>

			<para>MySQL proxy / MySQL-LB</para>

		</section>
		</section>
		<section>
			<title>高可用性集群</title>
			<para>俗称：双机热备份</para>
			<para>关键词：心跳线</para>
			<para>两部服务器，或多部服务器，形成一个集群，当主服务器崩溃是，立即切换到其它节点上。</para>
			<para>两部服务器要做到，内容实时同步，保持数据一直。</para>
			<para>一般用 heartbeat + DRBD 实现。heartbeat负责切换服务器，DRBD用于同步数据。</para>
		</section>
		<section>
			<title>负载均衡设备</title>
			<orderedlist>
				<title>负载均衡成熟产品</title>
				<listitem><para>F5 Big IP</para></listitem>
				<listitem><para>Array</para></listitem>
			</orderedlist>
			<para>这些设备可提供3,4,7层负载均衡HA，硬件已经压缩，HTTP头改写，URL改写...</para>
			<para>其中3层交换部分多采用硬件实现。</para>
			<para><ulink url="/intranet/index.html">更多关于F5 与 Array 资料点击进入</ulink></para>
		</section>
		<section>
			<title>会话保持</title>
		</section>
		<section>
			<title>健康状态检查</title>
		</section>
	</section>

	<section id="cache">
		<title>缓存技术</title>
		<para>首先要说明，很多缓存技术依赖静态化。下面展示了缓存可能出现的位置。</para>
		<para>用户user -> 浏览器缓存 IE/Firefox Cache -> 逆向代理缓存 Reverse proxy Cache -> WEB服务器缓存 Apache cache -> 应用程序缓存 php cache -> 数据库缓存 database cache</para>
		<para>当然交换机，网络适配器，硬盘上也有Cache 但这不是我们要讨论的范围。</para>
		<para>缓存存储方式主要是内存和文件两种，后者是存于硬盘中。</para>
		<orderedlist>
			<title>网站上使用的缓存主要包括五种：</title>
			<listitem><para>浏览器 缓存</para></listitem>
			<listitem><para>逆向代理/CDN缓存</para></listitem>
			<listitem><para>WEB服务器缓存</para></listitem>
			<listitem><para>应用程序缓存</para></listitem>
			<listitem><para>数据库缓存</para></listitem>
		</orderedlist>
		<para>将上面的缓存合理地，有选择性的使用可大大提高网站的访问能力。</para>
		<para>总之，想让你的网站更快，更多并发，答案是cache,cache 再 cache</para>
		<section>
			<title>浏览器缓存</title>
			<section>
				<title>Expires</title>
				<para>只要向浏览器输出过期时间HTTP协议头，不论是html还是动态脚本，都能被缓存。</para>
				<para>HTML META</para>
				<screen>
				<![CDATA[
<meta http-equive="Expires" content=" Mon, 10 Jan 2000 00:00:00 GMT"/>
<meta http-equive="Cache-Control" content="max-age=300"/>
<meta http-equive="Cache-Control" content="no-cache"/>
				]]>
				</screen>
				<para>动态脚本</para>
				<screen>
Expires: Mon, 10 Jan 2000 00:00:00 GMT
Cache-Control: max-age=300
Cache-Control: no-cache

header("Expires: " .gmdate ("D, d M Y H:i:s", time() + 3600 * 24 * 7). " GMT");
header("Cache-Control: max-age=300");
header("Cache-Control: no-cache");
				</screen>
				<para>很多web server都提供 Expires 模块</para>
				<tip><para>有些浏览器可能不支持。</para></tip>
			</section>
			<section>
				<title>If-Modified-Since / Last-Modified</title>
				<para>If-Modified-Since 小于 Last-Modified 返回 200</para>
				<screen>
neo@neo-OptiPlex-780:/tmp$ curl -I http://www.163.com/
HTTP/1.1 200 OK
Server: nginx
Content-Type: text/html; charset=GBK
Transfer-Encoding: chunked
Vary: Accept-Encoding
Expires: Mon, 16 May 2011 08:12:05 GMT
Cache-Control: max-age=80
Vary: User-Agent
Vary: Accept
Age: 38
X-Via: 1.1 ls100:8106 (Cdn Cache Server V2.0), 1.1 lydx156:8106 (Cdn Cache Server V2.0)
Connection: keep-alive
Date: Mon, 16 May 2011 08:11:23 GMT
				</screen>
				<para>If-Modified-Since 大于 Last-Modified 返回 304</para>
				<screen>
neo@neo-OptiPlex-780:/tmp$ curl -H "If-Modified-Since: Fri, 12 May 2012 18:53:33 GMT"  -I http://www.163.com/
HTTP/1.0 304 Not Modified
Content-Type: text/html; charset=GBK
Cache-Control: max-age=80
Age: 41
X-Via: 1.0 ls119:80 (Cdn Cache Server V2.0), 1.0 lydx154:8106 (Cdn Cache Server V2.0)
Connection: keep-alive
Date: Mon, 16 May 2011 08:11:14 GMT
Expires: Mon, 16 May 2011 08:11:14 GMT
				</screen>
			</section>
			<section>
				<title>ETag / If-None-Match</title>
				<screen>
neo@neo-OptiPlex-780:/tmp$ curl -I http://images.example.com/test/test.html
HTTP/1.1 200 OK
Cache-Control: s-maxage=7200, max-age=900
Expires: Mon, 16 May 2011 09:48:45 GMT
Content-Type: text/html
Accept-Ranges: bytes
ETag: "1984705864"
Last-Modified: Mon, 16 May 2011 09:01:07 GMT
Content-Length: 22
Date: Mon, 16 May 2011 09:33:45 GMT
Server: lighttpd/1.4.26
				</screen>
				<screen>
neo@neo-OptiPlex-780:/tmp$ curl -H 'If-None-Match: "1984705864"' -I http://images.example.com/test/test.html
HTTP/1.1 304 Not Modified
Cache-Control: s-maxage=7200, max-age=900
Expires: Mon, 16 May 2011 09:48:32 GMT
Content-Type: text/html
Accept-Ranges: bytes
ETag: "1984705864"
Last-Modified: Mon, 16 May 2011 09:01:07 GMT
Date: Mon, 16 May 2011 09:33:32 GMT
Server: lighttpd/1.4.26
				</screen>
			</section>
		</section>
		<section>
			<title>CDN/逆向代理缓存</title>
			<orderedlist>
				<title>具有代表性的逆向代理服务器：</title>
				<listitem><para>Squid</para></listitem>
				<listitem><para>Nginx</para></listitem>
				<listitem><para>Varnish</para></listitem>
				<listitem><para>Apache cache module</para></listitem>
			</orderedlist>
			<orderedlist>
				<title>其它逆向代理服务器</title>
				<listitem><para>一些提供cache的硬件设备</para></listitem>
				<listitem><para>最近几年出现了的 China Cache 服务商，也称CDN</para></listitem>
			</orderedlist>
			<para>很多CDN厂商使用Squid 二次开发做为CDN节点，通过全球负载均衡使用分发</para>
			<orderedlist>
				<title>这些CDN厂商主要做了一下二次开发</title>
				<listitem><para>logs 日志集中</para></listitem>
				<listitem><para>流量限制</para></listitem>
				<listitem><para>push,pull操作</para></listitem>
				<listitem><para>url 刷新</para></listitem>
			</orderedlist>
			<para>s-maxage 与 max-age用法类似，s-maxage针对代理服务器缓存。同样适用于CDN</para>
			<para>s-maxage 与 max-age 组合使用可以提高CDN性能</para>
		</section>
		<section>
			<title>负载均衡设备</title>
			<para>F5 Big-IP, Array 等设备都提供硬件加速，其原理与squid, apache提供的功能大同小异</para>
			<para>其中Array 页面压缩采用硬件压缩卡实现，SSL加速也采用硬件实现</para>
		</section>
		<section>
			<title>WEB服务器缓存</title>
			<para>例如，通过配置apache实现自身 cache</para>
		</section>
		<section>
			<title>应用程序缓存</title>
			<para>在这个领域百花齐放，相信你一定能找到适合你的。这些cache会为你提供一些api，来访问它。</para>
			<para>代表性的 memcached 据我所是sina广泛使用，腾讯也曾经使用过后来开发了TC(Tencent Cache)，台湾雅虎则使用APC Cache。</para>
			<para>另外模板引擎也有自己的缓存系统</para>
		</section>
		<section>
			<title>数据库缓存</title>
			<para>数据库本身就有这个配置选项，如果需要你仍然可以在数据库前面加一道Cache。</para>
			<para>例如PostgreSQL, MySQL 都提供参数可以将memcached编译到它内部</para>
		</section>
	</section>
	<section id="static">
		<title>静态化</title>
		<orderedlist>
			<title>静态化方法包括：</title>
			<listitem><para>生成方式</para></listitem>
			<listitem><para>抓取方式</para></listitem>
			<listitem><para>伪静态化</para></listitem>
			<listitem><para>混合方式</para></listitem>
		</orderedlist>
		<para>静态化可以改善SEO</para>
		<section>
			<title>生成方式</title>
			<para>主要由程序实现</para>
			<para>例如</para>
			<programlisting>
			<![CDATA[
content = "<html><title>my static</title><body>hello world</body></html>"
file = open( your static file)
file.write(content)
file.close()
			]]>
			</programlisting>
		</section>
		<section>
			<title>抓取方式</title>
			<para>主要由程序实现</para>
			<para>程序中抓取</para>
			<programlisting>
			<![CDATA[
content = get_url('http://netkiller.8800.org/index.php')
file = open( index.html)
file.write(content)
file.close()
			]]>
			</programlisting>
			<para>使用软件抓取，不仅限于wget。</para>
			<programlisting>
			<![CDATA[
wget http://netkiller.8800.org/index.php -O index.html
			]]>
			</programlisting>
			<para>这时只给出简单例子，使用复杂参数实现更复杂的拾取，然后将脚本加入crontab中可。</para>
		</section>
		<section>
			<title>伪静态化</title>
			<para>伪静态化是主要是通过在URL上做一些手脚，使你看去是静态的，实质上它是动态脚本。</para>
			<orderedlist>
			<title>伪静态化实现主要包括两种方法：</title>
				<listitem><para>Rewrite rule</para></listitem>
				<listitem><para>path_info</para></listitem>
			</orderedlist>
			<para>下面是一个PATH_INFO例子</para>
			<para>http://netkiller.8800.org/zh-cn/photography/browse/2009.html</para>
			<para>根本就不存在这个目录'zh-cn/photography/browse/'和文件'2009.html'</para>
			<para></para>
			<para>下面是一个Rewrite例子</para>
			<para>http://example.org/bbs/thread-1003872-1-1.html</para>
		</section>
		<section>
			<title>混合方式</title>
			<para>其实目前网站使用的基本上都是上面几种方法混合方式。</para>
			<para><![CDATA[例如首先将动态url(example.org/news.php?cid=1&id=1) 通过rewrite转换为 (example.org/new_1_1.html)]]></para>
			<para>接下来就比较容易解决了，一种方法是使用wget example.org/new_1_1.html，另一种方法你无需静态化，直接使用squid规则配置让他永不过期</para>
		</section>
		<section>
			<title>静态化中的动态内容</title>
			<para>在静态化页面中有一些内容是无法实现静态的。像登录信息，用户评论等等</para>
			<orderedlist>
				<title>我们用三种方法实现静态中嵌入动态内容：</title>
				<listitem><para>iframe - 灵活性差</para></listitem>
				<listitem><para>SSI - 消耗web服务器资源</para></listitem>
				<listitem><para>Ajax - 依赖浏览器，稳定性差</para></listitem>
			</orderedlist>
		</section>
	</section>
	<section id="media">
		<title>多媒体数据分离</title>
		<section>
			<title>图片服务器分离</title>
			<orderedlist>
				<title>为什么要将图片服务器分离出来？</title>
				<listitem><para>图片通常比较大，下载需要更长的时间，而web容器并发数也是相当宝贵的仅次于数据库。</para></listitem>
				<listitem><para>传统浏览器一个窗口只占用一个链接数，目前主流浏览器都支持多线程下载，下载HTML页面同时，采用多线程下载其它多媒体数据。</para></listitem>
			</orderedlist>
			<para>
				我们举一个例子，你的服务器并发能力只用1000，早期浏览器不支持多线程，所以同一时刻，你的服务器可以承受1000个人同时访问。
				但现在不同了，基本所有的浏览器都支持多线程，假如你的页面中有9张小图片,同一时刻你的服务器仅仅能应付1000/10 = 100个用户。
			</para>
			<para>所以我们要将图片和其他多媒体文件分离出来，单独使用一台服务器处理请求。</para>
			<tip><para>图片服务器建议使用lighttpd与squid缓存配合使用效果更好或购买CDN的服务。</para></tip>
		</section>
		<section>
			<title>目录层次规划</title>
			<para>日期有利于归档</para>
			<screen>
/www/images
/www/images/2008
/www/images/2008/01
/www/images/2008/01/01
			</screen>
			<para>分类不同用途的文件</para>
			<screen>
/www/images
/www/images/theme/2009

# article id 000001
/www/images/article/2009/01/000001

# product id 00001
/www/images/product/2009/01/01/00001

# member name neo
/www/images/member/2009/01/01/neo
			</screen>
			<para>根据你的数据量，创建目录深度, 并且目录深度有规律可循。</para>
			<para>虽然64bit 文件系统不限制文件数量与目录深度，但是我还是建议按我的方式规划目录。</para>
			<para>这样规划目录便于缓存控制，如：</para>
			<para>images/2008/* 永久缓存</para>
			<para>images/2009/* 缓存一个月</para>
			<para>images/2010/* 缓存一小时</para>
			<para>images/2010/06/* 缓存5分钟</para>
		</section>
		<section>
			<title>多域名访问</title>
			<para>部分浏览器（IE）相同域名只能创建2个线程，在页面中使用多个域名可以解决这个限制</para>
			<screen>
img1.example.com IN CNAME images.example.com.
img2.example.com IN CNAME images.example.com.
img3.example.com IN CNAME images.example.com.
...
imgN.example.com IN CNAME images.example.com.
			</screen>
		</section>
	</section>
	<section id="compress">
		<title>压缩数据传输</title>
		<para>服务器将html或脚本输出压缩，用户从服务器取得数据后由浏览器解压</para>
		<orderedlist>
			<title>压缩数据传输实现方法：</title>
			<listitem><para>apache mod_deflate</para></listitem>
			<listitem><para>lighttpd compress module</para></listitem>
		</orderedlist>
	</section>
	<section id="ntp">
		<title>时间同步</title>
		<para>将通信网上各种通信设备或计算机设备的时间信息(年月日时分秒)基于UTC（协调世界时）时间偏差限定在足够小的范围内（如100ms），这种同步过程叫做时间同步。 </para>
		<orderedlist>
			<title>关于时间同步我个人的解决方法：</title>
			<listitem><para>使用UTC时间，用户加时区来解决。</para></listitem>
			<listitem><para>保证所有服务器的时间是同步的</para></listitem>
		</orderedlist>
		<screen>
$ sudo ntpdate asia.pool.ntp.org
21 May 10:34:18 ntpdate[6687]: adjust time server 203.185.69.60 offset 0.031079 sec
		</screen>
	</section>
	<section id="email">
		<title>邮件系统</title>
		<orderedlist>
			<title>邮件系统：</title>
			<listitem><para>站内邮件。</para></listitem>
			<listitem><para>电子邮局服务</para></listitem>
			<listitem><para>订阅/推广邮件</para></listitem>
		</orderedlist>
	<!--
方案一：使用多个帐号轮循发送邮件并且邮件正文加入干扰字符，使963系统不能做指纹验证，如user1@example.com, user2@example.com 很多个帐号同事进行。可以解决时限问题。

方案二：自己架设邮件服务器
1. 可以解决全公司对邮件空间不足的需求。
2. 可以一并解决批量邮件发送问题
3. 在未来我们可以向example注册会员提供邮箱服务

但我不建议使用一台服务器，把公司邮件和推广邮件放到同一台服务器上，一旦遭到其他邮件提供上封杀，会影响我们正常使用。

我们自己架设邮件服务器可能存在的问题：
1. 垃圾邮件回收，我们的垃圾邮件过滤机制没有商业邮件系统完备，经常误判为垃圾邮件。
2. 邮件病毒处理, 我们使用的病毒匹配库也没有商业邮件系统全，更新也比较慢。
3. 遭遇其他邮件提供商封杀，其他邮件提供商收到我们大量推广邮件，可能认为是垃圾邮件，导致直接封掉我们的IP。

所以我建议如果自己架设邮件服务器，最好是公司邮箱与推广群发邮箱分开。做好域名反向解析与MX邮件交换记录，当遇到IP被封的时候，第一时间与邮件服务商沟通解决，对方是可以放行我们IP的。

技术选型：

我们可以采用Postfix 邮件系统。

架构方面：

我会考虑未来几年可能出现的需求，做到能及时有效应对各种变化。如：系统扩容，并发量，邮件存储以及分布式邮件系统。

安全问题：

另一个不被重视的问题，就是邮件安全问题，internet上的邮件是明文传播，接入方理论上可以看到我们发送的每一封电子邮件内容。在外国都采用数字签名技术加密邮件正文。
数字签名，可以监控邮件是否被中途修改过，另外没有数字证书也无法看到邮件内容。其实不难理解这个系统的原理和招商银行的网银系统原理完全一样。
我们可以从几个方面解决邮件安全问题：
1. 采用SSL POP3 与 SSL SMTP，可以保证邮件在传输过程中的安全
2. 邮件正文采用数字签名，即使获得邮件，也无法看到内容。
	 -->
	 	<section>
	 		<title>Mailing List</title>
	 		<orderedlist>
				<title>邮件列表系统：</title>
				<listitem><para>订阅功能</para></listitem>
				<listitem><para>确认订阅功能</para></listitem>
				<listitem><para>退订功能</para></listitem>
				<listitem><para>群发功能</para></listitem>
				<listitem><para>浏览功能(国内基本不需要)</para></listitem>
			</orderedlist>
	 	</section>
	</section>
	<section id="logs">
		<title>日志集中管理</title>
		<para>传统做法是文件型日志，分布在各个服务器上。在大规模部署服务器后代来很多不便，增加很多管理成本，所有我们需要集中管理服务器产生的所有日志，我们叫他日志中心服务器</para>
		<section>
			<title>系统日志</title>
			<screen>rsyslog/syslog-ng 实现日志集中管理</screen>
		</section>
		<section>
			<title>应用程序日志</title>
			<para>应用程序中没有比较大量记录日志，当开启debug模式时才记录大量日志。</para>
			<para>但是很多国内开发太过于依赖日志，导致日记非常臃肿</para>
			<para>程序日志解决方案，请看软件架构相关章节</para>
		</section>
	</section>
	<section id="ssl">
		<title>SSL</title>
		<para>SSL 加密传输，为电子商务提供交易安全保护，什么时候该使用 SSL呢：</para>
		<orderedlist>
			<title>使用SSL</title>
			<listitem><para>用户登录</para></listitem>
			<listitem><para>购物流程</para></listitem>
			<listitem><para>支付</para></listitem>
		</orderedlist>
		<para>什么时候不使用SSL? 经过SSL加密后，你就失去了很多功能，你不能在对页面做Cache/CDN，SSL加密与解密需要耗费你的服务器CPU与内存资源，能不使用尽量不使用。</para>
		<para>对于SSL消耗你服务器资源这方面有两个方案解决</para>
		<orderedlist>
			<listitem><para>将SSL证书安装到CDN上，目前蓝讯，网宿等等CDN厂商都提供SSL服务。我与上两家技术人员沟通过，也安装了证书实际测试一下，你可以放心是使用。</para></listitem>
			<listitem><para>将SSL证书安装到负载均衡设备，这些设备都采用专用硬件处理SSL请求，我测试过F5，Array，Banggoo</para></listitem>
		</orderedlist>
		<para>采用上面两种方案，无需改变你目前的服务器配置，他们的原理是</para>
		<screen>
		<![CDATA[
user (https://www.example.com) --> CDN or SLB (SSL) --> http://www.example.com
		]]>
		</screen>
		<para>用户访问https,到达CDN或者负载均衡，CDN/SLB 通过http://请求源站，然后将内容SSL加密，返回给用户，这样用户得到的是加密内容。</para>
		<para>用户提交数据，交给CDN/SLB，CDN/SLB将SSL加密数据卸载证书，然后将解密后数据发回源站。</para>
		<para>CDN与SLB加载卸载证书原理很简单，不难理解。</para>
		<para>我来教你DIY一个，你可以使用Squid，Nginx，Apache等等反向代理服务器，将证书安装在反向代理上，请求源站仍然采用http。</para>
		<tip>
			<title>SSL注意事项</title>
			<para>你如果认为把SSL挂载到网站前端就，大功告成，完事了，那你错了。</para>
			<para>幸运的话你会成功，但有时的时候你发现你的证书不被信任。如果你是个细心的人，你会发现单个图片，或者你创建换成测试文件 echo helloworld &gt; index.html 证书都是OK的。</para>
			<para>这个问题出在你的html页面中，安装有SSL证书的网站，不能有外链js,flash等等不安全内容。</para>
		</tip>
	</section>
	<section id="storage">
		<title>Storage 存储</title>
        <section>
            <title>存储种类</title>
            <para>DAS、NAS、SAN</para>

			<section>
				<title>Direct Attached Storage</title>
				<para>PC + Raid Card ====== Array</para>
			</section>

			<section>
				<title>Network-attached storage</title>
				<para>NAS 说白了就是一个嵌入式电脑，经过精简内核的Linux,通过samba,nfs,WebDav,ftp...等等方式实现共享存储</para>
				<para>如果你有兴趣，可以DIY一个NAS，使用Openfiler</para>
			</section>

			<section>
				<title>Storage area network</title>
				<para>只要你有￥什么都好说</para>
			    <section>
				    <title>FC SAN</title>
	                <para>FC 是光纤通道网络存储，需要专用交换机与HBA卡</para>
	                <para>提供 6G/8G 数据传输</para>
			    </section>
			    <section>
				    <title>IP SAN</title>
	                <para>1G/10G iSCSI，采用TCP/IP协议传输SCSI指令</para>
	                <para>客户端不需要专门的HBA卡，专业iSCSI HBA目前非常昂贵</para>
			    </section>
				<section>
					<title>FCoE (Fibre Channel over Ethernet)</title>
					<para>因为iSCSI很廉价，FC市场被iSCSI蚕食，传统FC收到iSCSI压力。推出新一代协议，希望能在现有光纤通道的成功基础上，借助于以太网的力量重新保持自身在数据中心存储局域网中的霸主地位。</para>
					<para>iSCSI通过TCP/IP协议在可能产生损耗或阻塞的局域网和宽带网上传送数据存储块。相比之下，FCoE则只是利用了以太网的拓展性，并保留了光纤通道在高可靠性和高效率方面的优势。</para>
				</section>
			</section>
        </section>
		<section>
			<title>RAID</title>
			<section>
				<title>缓存服务器</title>
				<para>全部采用RAID 0</para>
				<para>一旦出现问题，立即将其从集群中踢出去，带节点故障排除后，恢复它的功能。</para>
			</section>
			<section>
				<title>Web 服务器</title>
				<para>采用RAID 1</para>
				<para>服务器仅仅存放脚本程序，数据建议放在外挂存储上。</para>
			</section>
			<section>
				<title>数据库</title>
				<para>主服务器：建议采用 RAID 10</para>
				<para>数据库节点：建议采用 RAID 10</para>
				<para>数据库应尽量避免使用RAID 5，RAID 5在做校验过程时，效率会很低。</para>
				<para>数据库节点一旦出现问题，立即从集群中撤出，排除故障后，在回复使用。</para>
			</section>
			<section>
				<title>数据备份</title>
				<para>数据备份服务器建议采用RAID 5/6</para>
				<para>RAID 5 阵列容量计算公式 ：</para>
				<para>可用容量  =（n-1）/n的总磁盘容量（n为磁盘数）</para>
			</section>
		</section>

		<section>
			<title>File System 文件系统</title>
			<para>我个人推荐使用 ext4, xfs 或 reiserfs</para>
            <para>zfs 也不错</para>
		    <section>
			    <title>Distributed File System(DFS)</title>
			    <para>RAID 0提高吞吐能力是有限的，IO也会有瓶颈，NAS吞吐能力一样有限，SAN价格不菲。</para>
			    <para>DFS是一个不错的选择</para>
		    </section>
		</section>
		<section>
			<title>数据访问协议</title>
			<screen>
• 光纤通道管理
• iSCSI
• IP/RDMA
• iSER
• SRP
• NFS v3 和v4
• CIFS
• HTTP
• WebDAV
• FTP
• NDMP v4
			</screen>
		</section>
		<section>
			<title>数据管理</title>
            <section>
                <title>Share 共享</title>
            </section>
		    <section>
			    <title>Mirror 远程镜像同步</title>
		    </section>
		    <section>
			    <title>压缩与重复数据消除</title>
				<para>EMC Data Domain</para>
				<para>开源 Opendedup </para>
		    </section>
		    <section>
			    <title>Backup 备份与恢复</title>
				<para>Bacula/Zmanda</para>
		    </section>
		    <section>
			    <title>故障报告</title>
		    </section>

		</section>
	</section>
	<section id="snapshot">
		<title>磁盘快照</title>
		<para>下面流程是自动化完成，这里分部讲解</para>
		<procedure>
			<title>升级操作流程</title>
			<step>
				<para>数据备份</para>
				<para>通常绝大多数人，备份还采用 cp / tar / 以及稍微有点技术含量的rsync做差异备份 例如</para>
				<screen>
					<![CDATA[
cp -r /www/example.com/www.example.com /backup/www.example.com-2016-05-23
tar zcvf www.example.com-2016-05-23.tgz /www/example.com/www.example.com

rsync -auzv /www/example.com/www.example.com /backup/www.example.com-2016-05-23
					]]>
				</screen>
				<para>这种备份适合比较小的软件包，对于图片服务器什么的就比较耗时。我很早就开始尝试使用快照备份当时使用LVM，后来转为Btrfs文件系统，到2010的时候btrfs快照已经非常成熟.
				</para>
				<screen>
					<![CDATA[
[root@www.netkiller.cn www]# btrfs subvolume snapshot /www /www/backup_2016-05-23
Create a snapshot of '/www' in '/www/backup_2016-05-23'
					]]>
				</screen>
				<para>快照瞬间建立，使用下面命令查看快照</para>
				<screen>
					<![CDATA[
[root@www.netkiller.cn www]# btrfs subvolume list /www
ID 284 gen 18583 top level 5 path backup_2016-05-23
					]]>
				</screen>
				<para>挂载快照</para>
				<screen>
					<![CDATA[
[root@www.netkiller.cn www]# mount -t btrfs -o subvol=backup_2016-05-23 /dev/xvdb1 /mnt
[root@www.netkiller.cn www]# ll /mnt/
					]]>
				</screen>
				<para>
					关于BTRFS详细使用方法，请参考
					<ulink url="http://www.netkiller.cn/linux/index.html">《Netkiller Linux 手札》</ulink>
				</para>
			</step>
			<step>
				<para></para>
	
				<para></para>
			</step>
			<step>
				<para></para>
	
			</step>
			<step>
				<para></para>
				<substeps>
					<step>
						<para></para>
					</step>
					<step>
						<para></para>
					</step>
				</substeps>
			</step>
			<step>
				<para></para>
			</step>
		</procedure>
	
	</section>

</chapter>
